% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optpoli.r
\name{optpoli}
\alias{optpoli}
\alias{optpoli.datcbase}
\alias{optpoli.default}
\title{Otimizacao de curvas polinomiais por partes}
\usage{
optpoli(dat, ext, graus, pto_turbmax0, ..., opcoes)

\method{optpoli}{datcbase}(dat, ext, graus, pto_turbmax0, pto_ext0, opcoes)

\method{optpoli}{default}(dat, ext, graus, pto_turbmax0, vaz_ext0, zero_forcado, opcoes)
}
\arguments{
\item{dat}{objeto do tipo \code{datcbase} ou \code{data.table}. Ver Detalhes}

\item{ext}{dado para extensão do ajuste. Ver Detalhes}

\item{graus}{lista de até três posições indicando os graus de cada parte polinomial. Ver Detalhes}

\item{pto_turbmax0}{vetor de duas posicoes indicando coordenadas da conexão entre polinômios
ajustados aos dados históricos}

\item{...}{demais parâmetros específicos de cada método. Ver Detalhes}

\item{opcoes}{lista contendo opcoes extras para a otimizacao. Ver Detalhes}

\item{pto_ext0}{vetor de duas posicoes indicando coordenadas da conexão entre último polinômio
ajustados aos dados históricos e polinômio dos dados de extensão}

\item{vaz_ext0}{escalar indicando a vazão da conexão entre último polinômio ajustados aos dados
históricos e curva base}

\item{zero_forcado}{booleano indicando se o A0 deve ser restrito igual ao patamar de referência}
}
\value{
lista de objetos \code{polijusU}. Ver detalhes
}
\description{
Genérica e métodos para otimizacao dos ajustes polinomiais por partes a cada conjunto de dados
}
\details{
Esta funcao opera de maneria extremamente similar à \code{\link{fitpoli}}, sendo apenas um
wrapper para otimização dos hiperparâmetros do ajuste (i.e. \code{graus}, \code{pto_turbmax} e
\code{pto_ext} ou \code{vaz_ext}).

\code{graus} aqui deve ser fornecido como uma lista de vetores, onde cada elemento da lista
contém quais graus devem ser testados para cada parte polinomial (ver Exemplos para mais
detalhes). Como a decisão da configuração de graus é inteira, o que se faz é otimizar os
hiperparâmetros restantes para cada possível combinação de graus fornecida e selecionar aquela
cujo resultado final leval ao menor erro de ajuste.

\code{pto_turbmax0}, \code{pto_ext0} ou \code{vaz_ext0} são pontos os valores iniciais para
otimização e devem necessariamente ser supridos.

Por fim, \code{opcoes} pode ser passada como uma lista de até tres elementos lógicos nomeados

\describe{
\item{min_descont}{indicando se a descontinuidade entre partes deve ser minimizada}
\item{fix_turbmax}{indicando se o valor \code{pto_turbmax0} deve ser fixado na otimizacao}
\item{fix_ext}{indicando se o valor \code{(pto)|(vaz)_ext0} deve ser fixado na otimizacao}
}

A opção \code{min_descont} só é utilizada em casos de ajuste de dois polinômios aos dados
históricos, onde a suavidade na conexão não é obrigatória. Caso \code{opcoes$min_descont = TRUE},
após a otimização dos outros hiperparâmetros visando reduzir a descontinuidade da primeira
derivada da curva.

\code{fix_turbmax} e \code{fix_ext} permitem travar os valores iniciais \code{pto_turbmax0},
\code{pto_ext0} ou \code{vaz_ext0}
}
\examples{

# extrai uma curva base
dbase <- extraibase(dummydata)

# selecao do dado de extensao
ext <- 1

# um polinomio ao historico e um para extensao ---------------------------------------

# a lista de duas posicoes indica o ajuste de dois polinomios, testando os graus 2, 3 e 4
# em cada parte, para um total de 9 configuracoes possiveis
graus <- list(2:4, 2:4)

# heuristica para estimar a inicializacao do ponto de conexao com o dado de extensao
maxvaz   <- 1.1 * dbase$hist[, max(vazao)]
pto_ext0 <- c(maxvaz, dummydata$ext[[ext]](maxvaz))

ajustes2poli <- optpoli(dbase, "CAD", graus = graus, pto_ext0 = pto_ext0)

# dois polinomios historicos e um de extensao ----------------------------------------

# aumentamos a lista de graus para testar, pois agora sao tres polinomios
graus <- list(2:4, 2:4, 2:4)

# heuristica para estimar a inicializacao do ponto de conexao entre polinomios do dado historico
engef    <- attr(dbase, "vazef")
yturbmax <- dbase$hist[(vazao < engef * 1.05) & (vazao > engef * 0.95), mean(njus)]
pto_turbmax0 <- c(engef, yturbmax)

# utilizando minimizacao de descontinuidade
ajustes3poli <- optpoli(dbase, "CAD", graus = graus, pto_ext0 = pto_ext0, pto_turbmax0 = pto_turbmax0,
    opcoes = list(min_descont = TRUE))

# por fim, podemos ver uma compilacao de todos os ajustes com
do.call(summary, ajustes3poli)


# otimizacao de ajuste individual ----------------------------------------------------

# utilizando a segunda melhor curva base do ajuste2poli
polibase <- ajustes2poli[[2]]

# utilizando patamer 33.0
datind <- extraipats(dummydata, quais = 33)[[1]]

# inicializacao de vaz_ext0
vaz_ext0 <- datind[, max(vazao)]

# otimizacao com apenas um polinomio
ajustesind <- optpoli(datind, polibase, list(2:4), vaz_ext0 = vaz_ext0)

do.call(summary, ajustesind)

}
\seealso{
\code{\link{polijusU}} para detalhes do objeto retornado; \code{\link{fitpoli}} para
execucao de ajuste simples
}
